# 单列模式

- 单：单一，一个

- 例：实例

- 一个构造函数一生只能有一个实例

- > 不管你new多少次，都是这一个实例

## 应用：

- 自定义弹出层
- 结构：div>xxx，默认隐藏，在一定条件下显示
- 实现：每次显示都是一个新的div还是一个div来回来去的显示

```js
/**
 *
 * Person单例模式的核心代码
 *
 * let instance=null;
 *
 * function singleton(){
 *     if(!instance) instance=实例对象
 * }
 *
 * */

class Person {
    name='jack'
}
/* 加入单列模式核心代码 */
let instance=null
class AL{
    fun(){
        if ( !instance ) instance=new Person();
        return instance
    }
}
/**
 * 第一次调用AL的时候，instance是null
 *
 * 就执行new Person给instance赋值，从此以后instance就是一个person的实例了
 *
 * 返回instance
 *
 * 第二次调用AL的时候，此时instance是第一次new出来的实例
 *
 * if条件不会执行了，直接返回第一次实例的代码
 * */
const p1=new AL();
const p2=new AL();
console.log(p1.fun(),p2.fun())
console.log(p1.fun()===p2.fun())
```

### 单列模式改造

- 我需要把instance变量保存下来
- sing是一个函数，里面可以判断可以返回
- 以闭包的形式来执行一段代码
- 为了保存构造函数，把他也写道闭包里面

```js
/**
 *
 * Person单例模式的核心代码
 *
 * let instance=null;
 *
 * function singleton(){
 *     if(!instance) instance=实例对象
 * }
 *
 * */


/* 以闭包的形式把构造函数放在里面 */
const sing=(()=>{
    /* 真是构造函数体 */
    class Person {
        name='jack'
        constructor(a,b,c) {
            this.name=a
            this.age=b
            this.cla=c
            this.sac()
        }
        sac(){
            console.log("hello")
        }
    }
    /* 这个变量因为在一个不会被销毁的函数执行空间里面 */
    let instance=null
    return function sing(...arg) {
        if ( !instance ) instance=new Person(...arg)
        return instance
    }
})()
/**
 * 第一次调用AL的时候，instance是null
 *
 * 就执行new Person给instance赋值，从此以后instance就是一个person的实例了
 *
 * 返回instance
 *
 * 第二次调用AL的时候，此时instance是第一次new出来的实例
 *
 * if条件不会执行了，直接返回第一次实例的代码
 * */
const p1=sing('obj','男',18);	//
const p2=sing('aaa','bbb','ccc');
console.log(p1,p2)				//Person {name: 'obj', age: '男', cla: 18} Person {name: 'obj', age: '男', cla: 18}
console.log(p1===p2)
```