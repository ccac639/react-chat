# 数组回顾

JS的数组就是API的调用：

补充：普通语言的数组封装（比如java的ArrayList）

- 常见语言的数组不能存放不同的数据类型因此所有在封装时通常存放在数组中的是Object类型
- 常见语言的数组容量不会自动改变.（需要进行扩容操作）
- 常见语言的数组进行中间插入和删除操作性能比较低。

# 栈结构

栈也是一种非常常见的数据结构，并且在程序中的应用非常广泛

## 数组

- 我们知道数组是一种线性结构，并且可以在数组的任意位置插入和删除数据
- 但是有时候，我们为了实现某些功能，必须对这种任意性加以限制。
- 而栈和队列就是比较常见的受限的线性结构，我们先来学习栈结构

![image-20220220173009724](C:\Users\move\AppData\Roaming\Typora\typora-user-images\image-20220220173009724.png)

栈（stack），它是一种受限的线性表，后进先出（LIFO）

- 其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。
- LIFO（last in first out）表示就是后进入的元素，第一个弹出栈空间。类似于自动餐托盘，最后放上的托盘，往往先把拿出去使用
- 向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素：
- 从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

生活中

- 类似于栈的口自助餐的托盘，最新放上去的，最先被客人拿走使用
- 收到很多的邮件（实体的），从上往下依次处理这些邮件（最新到的邮件，最先处理口
- 注意：不允许改变邮件的次序，比如从最小开始，或者处于最紧急的邮件，否则就不再是栈结构了。而是队列或者优先级队列结构。

程序中什么是使用栈实现的呢？

- 学了这么久的编程，是否听说过，函数调用栈呢？
- 我们知道函数之间和相互调用：A调用B,B中又调用C,C中又调用D.
- 那样在执行的过程中，会先将A压入栈，A没有执行完，所有不会弹出栈在A执行的过程中调用了B，会将B压入到栈，这个时候B在栈顶，A在栈底
- 如果这个时候B可以执行完，那么B会弹出栈。但是B有执行完吗？没存它调用了C.
- 所以C会压栈，并且在栈顶。而C调用了D,D会压入到栈顶，所以当前的栈顺序是：栈顶A->B->C->D栈顶
- D执行完，弹出栈.C/B/A依次弹出栈。
- 所以我们有函数调用栈的称呼，就来自于它们内部的实现机制.（通过栈来实现的）

![image-20220220174245237](C:\Users\move\AppData\Roaming\Typora\typora-user-images\image-20220220174245237.png)

栈结构面试题

面试题目：有六个元素6,5,4,3,2,1的顺序进栈，问下列哪一个不是合法的出浅序列？（）

A.543612

B.453216

C346521

D.234156

解

```
A----6进栈-5进栈-5出栈-4进栈-4出栈-3进栈-3出栈-6出栈-2进栈-1进栈-1出栈-2出栈
```

```
B----6进栈-5进栈-4进栈-4出栈-5出栈-3进栈-3出栈-2进栈-2出栈-1进栈-1出栈-6出栈
```

```
C----6进栈-5进栈-4进栈-3进栈-3出栈-4出栈-！！ 必须5出栈-才能让6出栈！！
```

```
D----6进栈-5进栈-4进栈-3进栈-2进栈-2出栈-3出栈-4出栈-1进栈-1出栈-5出栈-6出栈
```

实现栈结构有两种比较常见的方式：

- 基于数组实现
- 基于链表实现

什么是链表？

- 也是一种数据结构，目前我们还没有学习，并且JavaScriptr中并没有自带链表结构
- 后续，我们会自己来实现链表结构，并且对比数组和链表的区别。

栈常见有哪些操作呢？

- push（element）：添加一个新元素到栈顶位置，
- pop()：移除栈顶的元素，同时返回被移除的元素。
- pek()：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它)
- isEmpty()：如果栈里没有任何元素就返回true，否则返回false。
- size()：返回栈里的元素个数。这个方法和数组的length属性很类似。
- toString()：将栈结构的内容以字符形式返回。

## 栈类

```
class Stack{
```

### 栈中的属性

```
    items=[]
```

### 将元素压入栈

```
    push(element){
        this.items.push(element)
    }
```

### 从栈中取出元素

```
    pop(){
        return this.items.pop()
    }
```

### 查看一下栈顶元素

```
    peek(){
        return this.items[this.items.length-1];
    }
```

### 判断栈是否为空

```
    isEmpty(){
        return this.items.length===0
    }
```

### 把数组转化为字符串

```
    toString(){
        // 20 10 12 8 7
        let str=''
        for (let i=0;i<this.items.length;i++){
            str+=`${this.items[i]}`
        }
        return str
    }
```

```
}
```

# 队列

## 受限的线性结构：

- 我们已经学习了一种受限的线性结构：栈结构
- 并且已经知道这种受限的数据结构对于解决某些特定问题，会有特别的效果
- 下面，我们再来学习另外一个受限的数据结构：队列。

队列（Queue），它是一种受限的线性表，先进先出（FIFO First In First Out）

- 受限之处在于它只允许在表的前端（front）进行删除操作
- 而在表的后端（rear）进行插入操作

生活中类似的队列结构

- 生活中类似队列的场景就是非常多了
- 比如在电影院，商场，甚至是厕所排队，
- 优先排队的人，优先处理.（买票，结账，WC）

## 打印队列：

- 有五份文档需要打印，这些文档会按照次序放入到打印队列中
- 打印机会依次从队列中取出文档，优先放入的文档，优先被取出，并且对该文档进行打印。
- 以此类推，直到队列中不再有新的文档

## 线程队列：

- 在开发中，为了让任务可以并行处理，通常会开启多个线程
- 但是，我们不能让大量的线程同时运行处理任务.（占用过多的资源）
- 这个时候，如果有需要开启线程处理任务的情况，我们就会使用线程队列。
- 线程队列会依照次序来启动线程，并且处理对应的任务

队列的实现和栈一样，有两种方案：

- 基于数组实现
- 基于链表实现

### 队列有哪些常见的操作呢？

- enqueue（element）：向队列尾部添加一个（或多个）新的项。
- dequeue()：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。
- front()：返回队列中第一个元素一最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回▣元素信息一与Stack类的peek方法非常类似）。
- isEmpty()：如果队列中不包含任何元素，返回true，否则返回false。
- size()：返回队列包含的元素个数，与数组的length属性类似。
- toString()：将队列中的内容，转成字符串形式

## 封装队列类

```
class Queue{
```

属性

```
    items=[];
```

将元素添加进来

        enqueue(ele){
            this.items.push(ele)
        }

从队列中删除前端元素

```
    dequeue(){
            return this.items.shift()
    }
```

查看前端元素

```
    First(){
        return this.items[0]
    }
```

查看队列是否为空

```
    isEmpty(){
        return this.items.length===0
    }
```

查看队列中的元素个数

```
    quantity(){
        return this.items.length
    }
```

toString 方法

```
    conversion(){
        let str=``
        for (let i=0;i<this.items.length;i++){
            str+=`${this.items[i]}`
        }
        return str
    }
```

```
}
```

# 优先级队列

- 我们知道，普通的队列插入一个元素，数据会被放在后端：并且需要前面所有的元素都处理完成后才会处理前面的数据。
- 但是优先级队列，在插入一个元素的时候会考虑该数据的优先级
- 和其他数据优先级进行比较，比较完成后，可以得出这个元素在队列中正确的位置
- 其他处理方式，和基本队列的处理方式一样

## 优先级队列主要考虑的问题

- 每个元素不再只是一个数据，而且包含数据的优先级在添加方式中
- ，根据优先级放入正确的位置

## 优先级队列的应用